{
  // the map to values
  const _ = require('lodash');
  const is = require('is_js');
  const path = require('path');
  const cimico = require('cimico');

  const types = require(path.join(__dirname, 'types'));

  const log = cimico({
    pretty: false,
  });

  log.p.log('Starting...');


  let findChild = false;

  const indentation = [0];
  function requiredIndentation() {
    return indentation[indentation.length - 1];
  }
  function pushIndentation(indent) {
    return indentation.push(indent);
  }
  function popIndetation() {
    return indentation.pop();
  }

}

start=
  keys:keyVal* {
    const config = new types.ObjectType();
    keys.forEach(({ key, type }) => {
      config.addChild(key, type);
    });
    config.read();
    const value = config.getValue();
    log.debug(value);
    return value;
  }

keyVal=
  keyBasic / keyObject / keyArrayBasic / keyArrayObject

keyBasic=
  linebreakOptional indent:indent key:identifier spaceOptional ':'  spaceOptional type:typeBasic spaceOptional linebreakRequired {
    const ri = requiredIndentation();
    if (ri !== indent && findChild === true) {
      throw new Error(`Looking for indentation of ${ri} at line: ${location().start.line} but found ${indent}`);
    }
    if (findChild === true) {
      findChild = false;
    }
    return { key, type, indent };
  }

child=
  found:keyVal & {
    log.debug('Found a possible child', found);
    const ri = requiredIndentation();
    if (found.indent !== ri) {
      log.f.log('Found non-child with indentation %b and required %b', found.indent, ri);
      return false;
    } else {
      log.f.log('Found child with indentation %b and required %b', found.indent, ri);
      return found;
    }
  } {
    return found
  }

keyObject=
  linebreakOptional indent:indent key:identifier spaceOptional ':' spaceOptional 'Object' ! {
    log.log('Object type found');
    pushIndentation(indent + 2);
    findChild = true;
  } spaceOptional linebreakRequired children:child+ {
    log.f.debug('Object %b(key) children found %d', key, children.length);
    const object = new types.ObjectType();
    children.forEach(({ key, type }) => {
      object.addChild(key, _.cloneDeep(type));
    });
    popIndetation();
    return { key, type: object, indent };
  }


keyArrayBasic=
  linebreakOptional indent:indent key:identifier spaceOptional ':' spaceOptional 'Array(' sec:typeBasic ')' spaceOptional '{' length:length '}' spaceOptional linebreakRequired {
    log.log(`Array of ${sec.name} type found`);
    const arr = new types.ArrayType();
    for (let i = 0; i < length; i += 1) {
      const item = _.cloneDeep(sec);
      arr.addChild(item);
    }

    return { key, type: arr, indent };
  }

keyArrayObject=
  linebreakOptional indent:indent key:identifier spaceOptional ':' spaceOptional 'Array(Object)' ! {
    log.log('Array of Object type found');
    pushIndentation(indent + 2);
    findChild = true;
  } spaceOptional '{' length:length '}' spaceOptional linebreakRequired children:child+ {
    log.f.debug('Array %b(key) children found %d', key, children.length);
    const array = new types.ArrayType();
    for (let i = 0; i < length; i++) {
      const object = new types.ObjectType();
      children.forEach(({ key, type }) => {
        object.addChild(key, _.cloneDeep(type));
      });
      array.addChild(object);
    }
    popIndetation();
    return { key, type: array, indent };
  }

typeBasic=
  typeString / typeInteger

typeString
  = 'String' {
    log.log('String type found');
    return new types.StringType();
  }

typeInteger
  = 'Integer' {
    log.log('Integer type found');
    return new types.IntegerType();
  }

linebreakOptional=
  space:[\n]* {
    log.debug('Optional line break found');
  }

linebreakRequired=
  space:[\n]+ {
    log.debug('Required line break found');
  }

identifier=
  first:[_a-zA-z] rest:([_0-9a-zA-z]*) {
    const id = first + rest.join('');
    log.f.log('Found identifier=%b', id);
    return id;
  }

indent=
  spaces:[ ]* {
    const length = spaces.length;
    log.f.log('Found %b spaces', length);
    return length;
  }

length=
  digits:[0-9]+ {
    const length = parseInt(digits.join(''), 10);
    log.f.log('Found length %b', length);
    return length;
  }

spaceRequired=
  [ \t]+ {
    log.debug('Required space found');
  }

spaceOptional=
  [ \t]* {
    log.debug('Optional space found');
  }
