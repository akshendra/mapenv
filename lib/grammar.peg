{
  // the map to values
  const _ = require('lodash');
  const is = require('is_js');
  const path = require('path');
  const cimico = require('cimico');

  const types = require(path.join(__dirname, 'types'));

  const log = cimico({
    pretty: false,
  });

  log.p.log('Starting...');


  let currentIndent = -1;

  const indentation = [-1];
  function requiredIndentation() {
    return indentation[indentation.length - 1];
  }
  function pushIndentation(indent) {
    return indentation.push(indent);
  }
  function popIndetation() {
    return indentation.pop();
  }

}

start=
  keys:keyVal* {
    const config = new types.ObjectType();
    keys.forEach(({ key, type }) => {
      config.addChild(key, type);
    });
    config.read();
    const value = config.getValue();
    log.debug(value);
    return value;
  }

keyVal=
  keyBasic / keyObject / keyArrayBasic



keyBasic=
  linebreakOptional indent:indent key:identifier spaceOptional ':'  spaceOptional type:typeBasic spaceOptional linebreakRequired {
    const ri = requiredIndentation();
    return { key, type, indent };
  }

child=
  found:keyVal & {
    log.debug('Found a possible child', found);
    const ri = requiredIndentation();
    if (found.indent !== ri) {
      log.f.log('Found non-child with indentation %b and required %b', found.indent, ri);
      return false;
    } else {
      log.f.log('Found child with indentation %b and required %b', found.indent, ri);
      return found;
    }
  } {
    return found
  }



keyObject=
  linebreakOptional indent:indent key:identifier spaceOptional ':' spaceOptional 'Object' ! {
    log.log('Object type found');
    pushIndentation(indent + 2);
  } spaceOptional linebreakRequired children:child+ {
    log.f.debug('Object %b(key) children found %d', key, children.length);
    const object = new types.ObjectType();
    children.forEach(({ key, type }) => {
      object.addChild(key, _.cloneDeep(type));
    });
    popIndetation();
    return { key, type: object, indent };
  }


keyArrayBasic=
  linebreakOptional indent:indent key:identifier spaceOptional ':' spaceOptional 'Array(' sec:typeWithArray ')' ! {
    pushIndentation(indent + 2);
  } spaceOptional '{' length:length '}' spaceOptional linebreakRequired children:child* {
    log.log(`Array of ${sec.name} type found and key=${key}`);

    const arr = new types.ArrayType();

    if (sec.name === 'Object') {
      if (children.length <= 0) {
        throw new Error('Object should have children', location());
      }

      children.forEach(({ key, type }) => {
        sec.addChild(key, _.cloneDeep(type));
      });
    }

    if (sec.name === 'Array' && sec.value[0].name === 'Object') {
      if (children.length <= 0) {
        throw new Error('Object should have children', location());
      }
      sec.value.forEach(obj => {
        children.forEach(({ key, type }) => {
          obj.addChild(key, _.cloneDeep(type));
        });
      });
    }

    for (let i = 0; i < length; i += 1) {
      const item = _.cloneDeep(sec);
      arr.addChild(item);
    }

    popIndetation();

    return { key, type: arr, indent };
  }

// keyArrayObject=
//   linebreakOptional indent:indent key:identifier spaceOptional ':' spaceOptional 'Array(Object)' ! {
//     log.log('Array of Object type found');
//     pushIndentation(indent + 2);
//     findChild = true;
//   } spaceOptional '{' length:length '}' spaceOptional linebreakRequired children:child+ {
//     log.f.debug('Array %b(key) children found %d', key, children.length);
//     const array = new types.ArrayType();
//     for (let i = 0; i < length; i++) {
//       const object = new types.ObjectType();
//       children.forEach(({ key, type }) => {
//         object.addChild(key, _.cloneDeep(type));
//       });
//       array.addChild(object);
//     }
//     popIndetation();
//     return { key, type: array, indent };
//   }

typeArray=
  'Array(' sec:typeWithArray ')' spaceOptional '{' length:length '}' {
    log.log('Array type found found');
    const array = new types.ArrayType();
    for (let i = 0; i < length; i+= 1) {
      array.addChild(_.cloneDeep(sec));
    }
    return array;
  }

typeObject=
  'Object' {
    log.log('Inside Object type found');
    return new types.ObjectType();
  }

anyExpectLineBreak=
  c:[^\n.]* {
    log.debug(c.join(''));
  }

typeString=
'String' {
    log.log('String type found');
    return new types.StringType();
  }

typeInteger=
  'Integer' {
    log.log('Integer type found');
    return new types.IntegerType();
  }

typeBasic=
  typeString / typeInteger

typeWithArray=
  typeBasic / typeArray / typeObject

linebreakOptional=
  space:[\n]* {
    // log.debug('Optional line break found');
  }

linebreakRequired=
  space:[\n]+ {
    // log.debug('Required line break found');
  }

identifier=
  first:[_a-zA-z] rest:([_0-9a-zA-z]*) {
    const id = first + rest.join('');
    log.f.log('Found identifier=%b', id);
    return id;
  }

indent=
  spaces:[ ]* {
    const length = spaces.length;
    // log.f.log('Found %b spaces', length);
    currentIndent = length;
    return length;
  }

length=
  digits:[0-9]+ {
    const length = parseInt(digits.join(''), 10);
    log.f.log('Found length %b', length);
    return length;
  }

spaceRequired=
  [ \t]+ {
    // log.debug('Required space found');
  }

spaceOptional=
  [ \t]* {
    // log.debug('Optional space found');
  }
