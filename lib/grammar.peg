{
  // the map to values
  const _ = require('lodash');
  const is = require('is_js');
  const path = require('path');
  const cimico = require('cimico');

  const types = require(path.join(__dirname, 'types'));

  const log = cimico({
    pretty: false,
  });

  log.p.log('Starting...');


  let currentIndent = -1;

  const indentation = [-1];
  function requiredIndentation() {
    return indentation[indentation.length - 1];
  }
  function pushIndentation(indent) {
    return indentation.push(indent);
  }
  function popIndetation() {
    return indentation.pop();
  }

  function replenishArray(parent, children) {
    if (parent.name !== 'Array') {
      return;
    }

    const subType = parent.value[0];
    if (subType.name === 'Object') {
      if (children.length <= 0) {
        throw new Error('Object should have children', location());
      }
      parent.value.forEach(st => {
        children.forEach(({ key, type:child }) => {
          st.addChild(key, _.cloneDeep(child));
        });
      });
      return;
    }

    replenishArray(subType, children);

    parent.value = parent.value.map(() => _.cloneDeep(subType));
  }

}

start=
  keys:keyVal* {
    const config = new types.ObjectType();
    keys.forEach(({ key, type }) => {
      config.addChild(key, type);
    });
    config.read();
    const value = config.getValue();
    log.debug(value);
    return value;
  }

keyVal=
  keyBasic


keyBasic=
  linebreakOptional indent:indent key:identifier spaceOptional ':'  spaceOptional type:typeWithArray ! {
    pushIndentation(indent + 2);
  } spaceOptional linebreakRequired children:child* {
    log.f.success('Reading type=%b', type.name);

    if (type.name === 'Object') {
      if (children.length <= 0) {
        throw new Error('Object should have children', location());
      }

      children.forEach(({ key, type:child }) => {
        type.addChild(key, _.cloneDeep(child));
      });
    }

    if (type.name === 'Array') {
      replenishArray(type, children);
    }

    log.debug(type);

    popIndetation();
    return { key, type, indent };
  }

child=
  found:keyVal & {
    log.debug('Found a possible child', found);
    const ri = requiredIndentation();
    if (found.indent !== ri) {
      log.f.log('Found non-child with indentation %b and required %b', found.indent, ri);
      return false;
    } else {
      log.f.log('Found child with indentation %b and required %b', found.indent, ri);
      return found;
    }
  } {
    return found
  }


typeArray=
  'Array(' sec:typeWithArray ')' spaceOptional '{' length:length '}' {
    log.f.log('Found %bu', 'Array');
    const array = new types.ArrayType();
    for (let i = 0; i < length; i+= 1) {
      array.addChild(_.cloneDeep(sec));
    }
    return array;
  }

typeObject=
  'Object' {
    log.f.log('Found %bu', 'Object');
    return new types.ObjectType();
  }

anyExpectLineBreak=
  c:[^\n.]* {
    log.debug(c.join(''));
  }

typeString=
'String' {
    log.f.log('Found %bu', 'String');
    return new types.StringType();
  }

typeInteger=
  'Integer' {
    log.f.log('Found %bu', 'Integer');
    return new types.IntegerType();
  }

typeBasic=
  typeString / typeInteger

typeWithArray=
  typeBasic / typeArray / typeObject

linebreakOptional=
  space:[\n]* {
    // log.debug('Optional line break found');
  }

linebreakRequired=
  space:[\n]+ {
    // log.debug('Required line break found');
  }

identifier=
  first:[_a-zA-z] rest:([_0-9a-zA-z]*) {
    const id = first + rest.join('');
    log.f.log('Found identifier=%b', id);
    return id;
  }

indent=
  spaces:[ ]* {
    const length = spaces.length;
    // log.f.log('Found %b spaces', length);
    currentIndent = length;
    return length;
  }

length=
  digits:[0-9]+ {
    const length = parseInt(digits.join(''), 10);
    log.f.log('Found length %b', length);
    return length;
  }

spaceRequired=
  [ \t]+ {
    // log.debug('Required space found');
  }

spaceOptional=
  [ \t]* {
    // log.debug('Optional space found');
  }
