{
  // the map to values
  const _ = require('lodash');
  const is = require('is_js');
  const path = require('path');
  const cimico = require('cimico');

  const types = require(path.join(__dirname, 'types'));

  const log = cimico('cimico:grammar', {
    pretty: false,
  });


  let currentIndent = -1;
  const indentation = [-1];

  function requiredIndentation() {
    const required = _.last(indentation);
    log.f.debug('Required indentation %bu', required);
    return required;
  }

  function pushIndentation(indent) {
    indentation.push(indent);
    log.f.debug('Pushed indentation %bu, length of stack %bu', indent, indentation.length);
  }
  function popIndetation() {
    const indent = indentation.pop();
    log.f.debug('Popped indentation %bu, length of stack %bu', indent, indentation.length);
    return indent;
  }

  function replenishArray(parent, children) {
    if (parent.name !== 'Array') {
      log.f.log('Replinishing array ended at %bu', parent.key);
      return;
    }

    const subType = parent.value[0]
    if (subType.name === 'Object') {
      log.log('Subtype is an Object');
      if (children.length <= 0) {
        throw new Error(`Object [${subtype.key}] should have children`);
      }
      log.log('Cloning children');
      parent.value.forEach(st => {
        children.forEach(({ key, type:child }) => {
          st.addChild(key, _.cloneDeep(child));
        });
      });
      return;
    }

    replenishArray(subType, children);

    parent.value = parent.value.map(() => _.cloneDeep(subType));
  }

}

start=
  keys:keyVal* {
    const config = new types.ObjectType();
    keys.forEach(({ key, type }) => {
      config.addChild(key, type);
    });
    return config;
  }

keyVal=
  keyBasic


keyBasic=
  linebreakOptional indent:indent key:identifier spaceOptional ':'  spaceOptional type:typeWithArray ! {
    pushIndentation(indent + 2);
  } spaceOptional validations:validations linebreakOptional children:child* {
    log.f.log('Reading type %bu at key %bu', type.name, key);

    type.addValidation(validations);

    if (type.name === 'Object') {
      if (children.length <= 0) {
        throw new Error(`Object [${key}] should have children`);
      }

      log.log('Cloning children');
      children.forEach(({ key, type:child }) => {
        type.addChild(key, _.cloneDeep(child));
      });
    }

    if (type.name === 'Array') {
      log.log('Cloning all children recursively');
      replenishArray(type, children);
    }

    popIndetation();
    return { key, type, indent };
  }

child=
  found:keyVal & {
    log.f.log('Found a possible child %bu', found.key);
    const ri = requiredIndentation();
    if (found.indent !== ri) {
      log.f.log('Found non-child with indentation %bu and required %bu', found.indent, ri);
      return false;
    } else {
      log.f.log('Found child with indentation %bu and required %bu', found.indent, ri);
      return found;
    }
  } {
    return found
  }


typeArray=
  'Array(' sec:typeWithArray ')' spaceOptional '{' length:length '}' {
    log.f.log('Found type %bu and subtype %bu', 'Array', sec.name);
    const array = new types.ArrayType();
    for (let i = 0; i < length; i+= 1) {
      array.addChild(_.cloneDeep(sec));
    }
    return array;
  }

typeObject=
  'Object' {
    log.f.log('Found type %bu', 'Object');
    return new types.ObjectType();
  }

typeString=
'String' {
    log.f.log('Found type %bu', 'String');
    return new types.StringType();
  }

typeNumber=
  'Number' {
    log.f.log('Found type %bu', 'Number');
    return new types.NumberType();
  }

typeBoolean=
  'Boolean' {
    log.f.log('Found type %bu', 'Boolean');
    return new types.BooleanType();
  }

typeBasic=
  typeString / typeNumber / typeBoolean

typeWithArray=
  typeBasic / typeArray / typeObject

validations=
  "[" spaceOptional before:validation spaceOptional "=>" spaceOptional transformer:validation spaceOptional "=>" spaceOptional after:validation   spaceOptional "]" {
    log.f.error('Found before %bu and after %bu', before, after);
    return { before, after, transformer };
  }
  / spaceOptional {
    log.debug('Found no validation');
    return { before: null, after: null, transformer: null }
  }

validation=
  rule:identifier {
    if (rule === '_') {
      return null;
    }
    return rule;
  }

linebreakOptional=
  space:[\n]* {
    log.debug('Optional line break found');
  }

linebreakRequired=
  space:[\n]+ {
    log.debug('Required line break found');
  }

identifier=
  first:[_a-zA-z] rest:[a-zA-Z0-9_]* {
    const id = first + rest.join('');
    log.f.error('Found identifier %b', id);
    return id;
  }

indent=
  spaces:[ ]* {
    const length = spaces.length;
    log.f.debug('Found %bu spaces for indent', length);
    currentIndent = length;
    return length;
  }

length=
  digits:[0-9]+ {
    const length = parseInt(digits.join(''), 10);
    log.f.debug('Found array length %bu', length);
    return length;
  }

spaceRequired=
  [ \t]+ {
    log.debug('Required space found');
  }

spaceOptional=
  spaces:[ \t]* {
    const length = spaces.length;
    log.f.debug('Found %bu spaces', length);
  }
